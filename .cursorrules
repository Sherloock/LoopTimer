Always add to the beginning of your message "I understood the rules for project TIMER" before you start working on the task! !!EXCEPT IF THIS IS A COMMIT SUMMARY!!

MY DEV ENV IS WINDOWS

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

If I use any of the following commands, you must generate the code for the command:
Commands = { "fiximp" => "fix all the imports in the project" }

## Project Context
This project is **TIMER** (workout timer).
The system allows users to create custom timers with intervals, loops, and advanced sequences.

## Tech Stack
- Next.js 14.2.5 (App Router) + React + TypeScript
- TailwindCSS + Shadcn UI (preferred) + Radix (only when needed)
- Lucide Icons
- React Hook Form + Zod
- Prisma + Prisma Studio
- @tanstack/react-query

## Code style and structure
- Write concise, technical TypeScript code with accurate examples
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasSolution)
- Keep functions small and focused (single responsibility)
- Add comments only for complex logic (explain "why", not "what")

## Constants and "no magic values" (CRITICAL)
- **Avoid magic values**: Defaults, thresholds, timings, delays, labels, storage keys, route strings, query keys, and event names must be centralized as typed constants.
- Create constants in `@/lib/constants/*` (feature-based modules) and optionally re-export from `@/lib/constants`.
- **Never hardcode localStorage/sessionStorage keys**: define `STORAGE_KEYS` constants.
- **Never hardcode custom event names**: define `CUSTOM_EVENTS` constants.
- **Never hardcode react-query keys**: define `QUERY_KEYS` constants.
- **Never hardcode route strings**: define routes in `ROUTES` (see Navigation Patterns below).

## TypeScript strictness (CRITICAL)
- This project should be treated as TypeScript strict: keep type-safety high.
- Prefer `unknown` over `any`, then narrow with type guards.
- Define proper types/interfaces for complex objects (timers, intervals, loops, saved presets).
- Use Zod for runtime validation at boundaries (API routes, forms, server actions).
- Avoid magic string unions in implementation: prefer `as const` objects or enums for finite states.

## Syntax and Formatting
- Use TypeScript, TailwindCSS, Shadcn UI syntax and formatting guidelines
- Always use import aliases (`@/`) where possible; avoid deep relative paths
- Always merge classes with the `cn` function
- Use boolean casting like `!!x` instead of `Boolean(x)`
- Always add `id` to toast messages, e.g. `toast.success("Timer saved!", { id: "save-timer" })`
- **ALWAYS wrap `useSearchParams()` in a Suspense boundary** (separate component + `<Suspense fallback={...}>`) to avoid build/runtime issues
- Prefer `@/components/ui/...` (Shadcn) instead of using Radix directly
- Path conventions:
  - `@/actions/...` for server actions
  - `@/lib/...` for libraries/utilities
  - `@/types/...` for types
  - `@/hooks/...` for hooks
  - `@/utils/...` for pure utils
  - `@/schema/...` for Zod schemas
  - `@/prisma` for Prisma client exports and DB access

## Authentication (Clerk)
- In server actions that require auth, always call `const userId = await checkAuth();` from `@/actions/auth/authCheck`.
- In API routes, verify auth server-side (never rely on client checks).
- Handle auth errors gracefully without leaking sensitive details.

## Database (Prisma)
- Use Prisma's type-safe queries; avoid raw SQL unless necessary.
- Use transactions for operations that must succeed/fail together.
- Always validate user ownership before modifying timer data.
- Use `select` to only fetch needed fields for performance.
- Handle Prisma errors gracefully with user-friendly messages.

## Navigation Patterns
- Use centralized navigation utilities in `@/lib/navigation.ts`
- Prefer `useNavigation()` hook over direct `router.push()` calls
- Define all routes in `ROUTES` constant for maintainability (no hardcoded strings)
- Use descriptive function names like `goToAdvancedTimer()` instead of generic `navigate()`

## UI and Styling (mobile-first CRITICAL)
- Use Shadcn UI components and styling + TailwindCSS utility classes
- **Mobile-first responsive design** is mandatory: toolbars/action bars stack on mobile (`flex-col`) and row on larger screens (`sm:flex-row`)
- Prefer `w-full sm:w-auto` for toolbar buttons and actions (better touch targets)
- Avoid horizontal scrolling; use `flex-wrap` or vertical stacking
- Icons: use Lucide Icons sized with `size={20}` or `size={16}` or `size={12}` (do not use other sizes or `w-4 h-4` classes)
- Use `rounded-lg` as the standard radius for buttons/cards (avoid `rounded-full` unless truly needed)
- Prefer container-based visual grouping (border/background) for logical groupings; avoid purely decorative indicators that consume layout space
- **NEVER use `<img>`**: always use Next.js `Image` from `next/image`
- Prefer Skeleton loaders for content loading states (Shadcn `Skeleton`) over generic spinners
- **NEVER use `confirm()`, `alert()`, `prompt()`**: use Shadcn dialogs/alert dialogs and toasts
- Inputs:
  - For time/number inputs use `inputMode="numeric"` and `pattern="[0-9:]*"` to improve mobile UX
  - Prefer wider input fields (e.g. `w-24`+) and larger touch targets on mobile
  - Add a short comment when overriding default sizing for UX reasons
- Always use Lucide icons in action buttons (especially in dialogs/action bars) for clarity

## React Hooks Best Practices (CRITICAL)
- Never call React Hooks conditionally; hooks must be top-level and stable order.
- All early returns must happen after hooks are declared.
- Use `useCallback` for functions used inside effects and include proper dependencies.
- Clean up event listeners/observers in `useEffect` cleanups.

## Performance Optimization
- Minimize bundle size using code splitting and `next/dynamic` for non-critical UI.
- Use proper caching strategies (React Query query keys must be centralized).
- Avoid unnecessary re-renders (memoize expensive computations, stable props).
- Always clean up event listeners, timeouts, intervals, and observers.

## Security
- Implement Content Security Policy where applicable.
- Sanitize/validate user inputs (Zod at boundaries).
- Handle sensitive data properly (never log secrets).
- Implement proper CORS handling for API routes when cross-origin is expected.

## Development Server Management
- Do not automatically start or restart the dev server (`npm run dev`).
- Only suggest running the server when explicitly needed for testing.

## Linting and Code Quality
- Never introduce unused variables/imports; remove immediately.
- In catch blocks, omit unused error param: `catch { ... }`.
- Prefix intentionally unused variables with underscore: `_unused`.
- After substantive edits, run lint checks and fix new issues.

## Documentation
- Donâ€™t create new documentation files for every small change.
- Update existing docs/README only when behavior/setup changed.

## Workflow rules
- always check version in package.json, and include the exact version in your answer
- Do not ask for confirmation before making changes that the user has explicitly requested.
- AFTER YOU FINISH A TASK MAKE SURE TO SUGGEST RULES FOR .cursorrules ADDITIONS.

## Git Usage (if asked to commit)
Commit Message Prefixes:
- "fix:" for bug fixes
- "feat:" for new features
- "perf:" for performance improvements
- "docs:" for documentation changes
- "style:" for formatting changes
- "refactor:" for code refactoring
- "test:" for adding missing tests
- "chore:" for maintenance tasks

Rules:
- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable